https://git-scm.com/docs

# Terminal Crash Course (Windows)
ls -> print current directory
ls -a -> print also hidden files 
start . -> open explorer in particular directory
cd -> change direction
.. cd -> go one directory back
pwd -> print current directory/location
mkdir <name of folder> -> create folder
touch <name of file.ext> -> create file
rm <name of file.ext> -> delete file (permament - attention: file is gone!)
rm -rf <name of folder> delete a directory (flags: r = recursive, f = force)

==========================================

# The Very Basics Of Git: Adding & Committing
git status -> gives information on the current status of a git repi and its content
git init -> Initialize git repo (.git)
Git tracks top-down (nested folders - do not init a repo inside of a repo)

Working Directory --- git add ---> Staging --- git commit ---> Repo (short form: git commit -a -m "commit message")

Use "git add" to group changed files together to staging phase to prepare for commit, then commit it to repo

git log -> retrieve information of the commits

==========================================

# Commits in Detail
Make atomic commits - each commits should focus on a single thing (for example one feature)
Use present tense imperative style for commit messages
When you use only "git commit" it will open defalut editor VIM to write commit message. If you write ":wq " and then enter to go out of VIM.
So therefore we will use another default editor (VS) -> git config --global core.editor "code --wait"

git log --oneline -> commit message is prefixed with information on the same line (format logs)
git commit --amend -> If you forgot a file or made a typo in (just one) commit message (ago), instead of making a new commit you can amend a commit 
Example:
git commit -m "some commit"
git add forgotten_file 
git commit --amend (amend will open editor - if you had a typo in commit message you can edit it here)

If you just had a typo you can just use "git commit --amend" to fix it in the editor

.gitignore -> file to tell git what to ignore (for example: log files, operating system files, secrets, api key, dependencies)

.DS_Store will ignore files named .DS_Store
folderName/ will ignore an entire directory
*.log will ignore any files with .log extension


==========================================

# Working with Banches
Master is just another branch.
HEAD is a pointer that refers to the current "location" in your repo. Points to a particular branch (for example HEAD -> master)

git branch -> show current branches
git branch <branch-name> -> create a new branch (based upon the current HEAD... if you branch from branch it will use this branch as starting point)
git switch <branch-name> -> switch between branches (old way: git checkout - does a lot more)
git switch -c <branch-name> -> create and switch to a new branch

If you switch a branch with unstaged changes, you will get an error. The new branch will not about these changes. Options: commit or stash.
BUT: If you have no conflicts when you switch between the branches, the changes will be switched too. So you will have the changes you made in the file you switched to.

git branch -d <branch-name> -> delete branch when its fully merged. You can't be in the branch you want to delete.
git branch -D <branch-name> -> delete force branch, even when its not fully merged.
git branch -m <new-branch-name> -> rename (move) branch name. You have to be in this branch.
git branch -v -> get a little bit more info: last commit + message

==========================================

# Merging Branches

Incorporate changes from one branch into another.
- we merge branches, not specific commits
- we always merge to the current HEAD branch (switch to the branch you want merge into)

Fast-Forward Merge
git switch master -> git merge <feature-branch-name> -> merge feauture branch into master branch. 
Fast-Forward: No other commits from master. One branch has just additional commits (feauture branch). The other (master) doesn't have additional commits. It's a easy merge.


Non-Fast-Forward Merge
Scenario: I work on feature and make two commits. On the master someone else worked on and commited something new. If I want to merge and I don't get a merge conflict git will automatically generate 
a merge commit. It will look like fast-forward merge, but it's a non-fast-forward one.
If there is a conflict, we have to manually resolve it and git will automatically  generate a merge commit again.

Merge conflicts
<<<<<HEAD
some code
=====
The content from your current HEAD (the branch you are trying to merge content into) is displayed between <<<HEAD and ==== symbols. (Accept Current Change, VS)
 
=====
conflict code
>>>>>feature-branch

The content from the branch you are trying to merge from is display between the ==== and >>>> symbols. (Accecpt incoming change, VS)

How to resolve:
1. Open the files with merge conflicts
2. Edit file to remove the conflicts. Decide which you want to keep or keep both.
3. Remove the conflict "markers" (symbols) in the document.
4. Add your changes and then make a commit.


==========================================

# Comparing Changes with Git Diff

We can use git diff to view changes between commits, branches, files, our working directory.

git diff -> Without additional options, git diff will list all the changes in our working directory that are not staged for the next commit. (only unstaged)
git diff HEAD -> lists all changes in the working tree since your last commit (staged and unstaged)
git diff --staged or --cached -> will list the changes between the staging area and our last commit. (only staged)
git diff --option <filename> -> show change from only the file.
git diff branch1..branch2 -> will list the changes between the tips of branch1 and branch2
git diff commit1..commit2 -> compare two commits, provide git diff with the commit hashes of the commits in question

Reading diff

diff --git a/file.txt b/file.txt (mostly same files - differences between these two files)
index commit...hash (meta data - not important - hashes between the hashes of two files being compared)
--- a/oldversion.format (file A gets - symbol for indicating changes)
+++ b/oldversion.format (file B gets + symbol for indicating changes)
@@ chunk header @@ (- shows where file A starts (-3,) and how many lines are shown (-3,4). + shows the same thing but for file B (+start,how many lines) )
chunk body (show what was changed)
